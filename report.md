UECM3033 Assignment #2 Report
========================================================

- Prepared by: ** Wong Sin Yi **
- Tutorial Group: T2

--------------------------------------------------------

## Task 1 --  $LU$ Factorization or SOR method

The reports, codes and supporting documents are to be uploaded to Github at: 

[https://github.com/kenziSY/UECM3033_assign2](https://github.com/kenziSY/UECM3033_assign2)

Explain your selection criteria here. 
Basically, LU method can be applied for any matrix. However, It attempts to solve the the problem by a finite sequence of operations. Therefore, it subjects to the roundoff error. Usually, it would be expensive for large system and requires large storage. For the SOR, each iterations improves accuracy and reduces error. SOR methods are useful even for linear problems involving a large number of variables . However, the SOR methods require a symmetric linear system and positive definite matrix. The parameter omega(w) is also required to ensure the convergence. My condition is set to be "np.count_nonzero(A) > 1/2*len(A)" . It represent sparse matrices by noting which elements are nonzero.Thus if the nonzeros is greater that half of the length of matrix A then we will choose LU method or otherwise. So the SOR will be useful and potentially faster for sparse system.


Explain how you implement your `task1.py` here.
The functions of LU, SOR and solve are defined. The value of omega(w) is set to be 1.03, which is within the range of convergence rate, 0 < w < 2. The condition is set and implemented. The iteration limit is assumed to be 10. So the iteration will not loop until infinity task. The solve function is run based on the conditions for the matrix to be well suited.

---------------------------------------------------------

## Task 2 -- SVD method and image compression

Put here your picture file (Deadpool.jpg)

![Deadpool.jng](https://github.com/kenziSY/UECM3033_assign2/blob/master/Deadpool.jpg)

How many non zero element in $\Sigma$?
The number of non zero elements in $\Sigma$ of red, green, blue matrix are 800 , 800 and 800 respectively.

Put here your lower and better resolution pictures. Explain how you generate these pictures from `task2.py`.

![lower-resolution.png](https://github.com/kenziSY/UECM3033_assign2/blob/master/low-resolution.png)

When the resolution is lower , $\Sigma_{30}$.

![better-resolution.png](https://github.com/kenziSY/UECM3033_assign2/blob/master/better-resolution.png)

When the resolution is better, $\Sigma_{200}$.

The above two figures are generated by keeping the first 30 and 200 non-zero elements and others become zero. The 3 colors red, green and blue are represented by the 3 dimensional matrices of r, g, and b respectively. To keep the first non-zero elements and set others to be zero is by using "np.zeros_like(Sr[n:800])". To avoid the dimensional error, the "sp.linalg.diagsvd" is used when performing the dot multiplication between the U and Sr matrices of red, green and blue. Then, the new matrices are created by the "np.dot". The new image is created then by combining the three matrices and is plotted by using "plt.figure".

What is a sparse matrix?
A sparse matrix is a matrix which most of the elements are zero. Sparse matrices store only the non-zero elements of a matrix, by using a one-dimensional real array for the non-zero elements and corresponding integer one-dimensional arrays for the rows and columns. The sparse matrix can be used and yield huge savings in memory when compared to the basic approach. Therefore, some algorithms can be performed faster by using sparse matrix because the speeds depend on the number of non-zero elements not the total number of elements.

-----------------------------------

<sup>last modified: 11/3/2016 </sup>
